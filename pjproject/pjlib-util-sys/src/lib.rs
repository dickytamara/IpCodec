/* automatically generated by rust-bindgen 0.58.1 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
extern crate pj_sys;
use std::{ffi::c_void, os::raw::{c_char, c_int, c_uint}};

use pj_sys::*;

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const PJLIB_UTIL_ERRNO_START: u32 = 320000;
pub const PJLIB_UTIL_ESTUNRESOLVE: u32 = 320001;
pub const PJLIB_UTIL_ESTUNINMSGTYPE: u32 = 320002;
pub const PJLIB_UTIL_ESTUNINMSGLEN: u32 = 320003;
pub const PJLIB_UTIL_ESTUNINATTRLEN: u32 = 320004;
pub const PJLIB_UTIL_ESTUNINATTRTYPE: u32 = 320005;
pub const PJLIB_UTIL_ESTUNININDEX: u32 = 320006;
pub const PJLIB_UTIL_ESTUNNOBINDRES: u32 = 320007;
pub const PJLIB_UTIL_ESTUNRECVERRATTR: u32 = 320008;
pub const PJLIB_UTIL_ESTUNNOMAP: u32 = 320009;
pub const PJLIB_UTIL_ESTUNNOTRESPOND: u32 = 320010;
pub const PJLIB_UTIL_ESTUNSYMMETRIC: u32 = 320011;
pub const PJLIB_UTIL_ESTUNNOTMAGIC: u32 = 320012;
pub const PJLIB_UTIL_ESTUNFINGERPRINT: u32 = 320013;
pub const PJLIB_UTIL_EINXML: u32 = 320020;
pub const PJLIB_UTIL_EINJSON: u32 = 320030;
pub const PJLIB_UTIL_EDNSQRYTOOSMALL: u32 = 320040;
pub const PJLIB_UTIL_EDNSINSIZE: u32 = 320041;
pub const PJLIB_UTIL_EDNSINCLASS: u32 = 320042;
pub const PJLIB_UTIL_EDNSINNAMEPTR: u32 = 320043;
pub const PJLIB_UTIL_EDNSINNSADDR: u32 = 320044;
pub const PJLIB_UTIL_EDNSNONS: u32 = 320045;
pub const PJLIB_UTIL_EDNSNOWORKINGNS: u32 = 320046;
pub const PJLIB_UTIL_EDNSNOANSWERREC: u32 = 320047;
pub const PJLIB_UTIL_EDNSINANSWER: u32 = 320048;
pub const PJLIB_UTIL_DNS_RCODE_START: u32 = 320050;
pub const PJLIB_UTIL_ESTUNTOOMANYATTR: u32 = 320110;
pub const PJLIB_UTIL_ESTUNUNKNOWNATTR: u32 = 320111;
pub const PJLIB_UTIL_ESTUNINADDRLEN: u32 = 320112;
pub const PJLIB_UTIL_ESTUNIPV6NOTSUPP: u32 = 320113;
pub const PJLIB_UTIL_ESTUNNOTRESPONSE: u32 = 320114;
pub const PJLIB_UTIL_ESTUNINVALIDID: u32 = 320115;
pub const PJLIB_UTIL_ESTUNNOHANDLER: u32 = 320116;
pub const PJLIB_UTIL_ESTUNMSGINTPOS: u32 = 320118;
pub const PJLIB_UTIL_ESTUNFINGERPOS: u32 = 320119;
pub const PJLIB_UTIL_ESTUNNOUSERNAME: u32 = 320120;
pub const PJLIB_UTIL_ESTUNUSERNAME: u32 = 320121;
pub const PJLIB_UTIL_ESTUNMSGINT: u32 = 320122;
pub const PJLIB_UTIL_ESTUNDUPATTR: u32 = 320123;
pub const PJLIB_UTIL_ESTUNNOREALM: u32 = 320124;
pub const PJLIB_UTIL_ESTUNNONCE: u32 = 320125;
pub const PJLIB_UTIL_ESTUNTSXFAILED: u32 = 320126;
pub const PJLIB_UTIL_EHTTPINURL: u32 = 320151;
pub const PJLIB_UTIL_EHTTPINPORT: u32 = 320152;
pub const PJLIB_UTIL_EHTTPINCHDR: u32 = 320153;
pub const PJLIB_UTIL_EHTTPINSBUF: u32 = 320154;
pub const PJLIB_UTIL_EHTTPLOST: u32 = 320155;
pub const PJ_CLI_EEXIT: u32 = 320201;
pub const PJ_CLI_EMISSINGARG: u32 = 320202;
pub const PJ_CLI_ETOOMANYARGS: u32 = 320203;
pub const PJ_CLI_EINVARG: u32 = 320204;
pub const PJ_CLI_EBADNAME: u32 = 320205;
pub const PJ_CLI_EBADID: u32 = 320206;
pub const PJ_CLI_EBADXML: u32 = 320207;
pub const PJ_CLI_EAMBIGUOUS: u32 = 320208;
pub const PJ_CLI_ETELNETLOST: u32 = 320211;
pub const PJ_DNS_MAX_IP_IN_A_REC: u32 = 8;
pub const PJ_DNS_SRV_MAX_ADDR: u32 = 8;
pub const PJ_DNS_MAX_NAMES_IN_NAMETABLE: u32 = 16;
pub const PJ_DNS_RESOLVER_MAX_NS: u32 = 16;
pub const PJ_DNS_RESOLVER_QUERY_RETRANSMIT_DELAY: u32 = 2000;
pub const PJ_DNS_RESOLVER_QUERY_RETRANSMIT_COUNT: u32 = 5;
pub const PJ_DNS_RESOLVER_MAX_TTL: u32 = 300;
pub const PJ_DNS_RESOLVER_INVALID_TTL: u32 = 60;
pub const PJ_DNS_RESOLVER_GOOD_NS_TTL: u32 = 600;
pub const PJ_DNS_RESOLVER_BAD_NS_TTL: u32 = 60;
pub const PJ_DNS_RESOLVER_MAX_UDP_SIZE: u32 = 512;
pub const PJ_DNS_RESOLVER_RES_BUF_SIZE: u32 = 512;
pub const PJ_DNS_RESOLVER_TMP_BUF_SIZE: u32 = 4000;
pub const PJ_SCANNER_USE_BITWISE: u32 = 1;
pub const PJSTUN_MAX_ATTR: u32 = 16;
pub const PJ_CRC32_HAS_TABLES: u32 = 1;
pub const PJ_HTTP_DEFAULT_TIMEOUT: u32 = 60000;
pub const PJ_CLI_POOL_SIZE: u32 = 1024;
pub const PJ_CLI_POOL_INC: u32 = 512;
pub const PJ_CLI_MAX_CMDBUF: u32 = 512;
pub const PJ_CLI_MAX_ARGS: u32 = 8;
pub const PJ_CLI_MAX_HINTS: u32 = 32;
pub const PJ_CLI_MAX_SHORTCUTS: u32 = 4;
pub const PJ_CLI_CONSOLE_POOL_SIZE: u32 = 256;
pub const PJ_CLI_CONSOLE_POOL_INC: u32 = 256;
pub const PJ_CLI_TELNET_POOL_SIZE: u32 = 1024;
pub const PJ_CLI_TELNET_POOL_INC: u32 = 512;
pub const PJ_CLI_MAX_CHOICE_VAL: u32 = 64;
pub const PJ_CLI_MAX_CMD_HISTORY: u32 = 16;
pub const PJ_SHA1_DIGEST_SIZE: u32 = 20;
pub const PJ_HTTP_HEADER_SIZE: u32 = 32;
pub const PJ_CLI_CONSOLE_LOG_LEVEL: u32 = 5;
pub const PJ_CLI_TELNET_LOG_LEVEL: u32 = 4;
pub const PJ_CLI_TELNET_PORT: u32 = 0;


#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_getopt_option {
    pub name: *const c_char,
    pub has_arg: c_int,
    pub flag: *mut c_int,
    pub val: c_int,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_crc32_context {
    pub crc_state: pj_uint32_t,
}



#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_md5_context {
    pub buf: [pj_uint32_t; 4usize],
    pub bits: [pj_uint32_t; 2usize],
    pub in_: [pj_uint8_t; 64usize],
}



#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_hmac_md5_context {
    pub context: pj_md5_context,
    pub k_opad: [pj_uint8_t; 64usize],
}



#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_sha1_context {
    pub state: [pj_uint32_t; 5usize],
    pub count: [pj_uint32_t; 2usize],
    pub buffer: [pj_uint8_t; 64usize],
}



#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_hmac_sha1_context {
    pub context: pj_sha1_context,
    pub k_opad: [pj_uint8_t; 64usize],
}



pub const PJ_DNS_CLASS_IN: u32 = 1;
pub type _bindgen_ty_11 = u32;

pub const PJ_DNS_TYPE_A: pj_dns_type = 1;
pub const PJ_DNS_TYPE_NS: pj_dns_type = 2;
pub const PJ_DNS_TYPE_MD: pj_dns_type = 3;
pub const PJ_DNS_TYPE_MF: pj_dns_type = 4;
pub const PJ_DNS_TYPE_CNAME: pj_dns_type = 5;
pub const PJ_DNS_TYPE_SOA: pj_dns_type = 6;
pub const PJ_DNS_TYPE_MB: pj_dns_type = 7;
pub const PJ_DNS_TYPE_MG: pj_dns_type = 8;
pub const PJ_DNS_TYPE_MR: pj_dns_type = 9;
pub const PJ_DNS_TYPE_NULL: pj_dns_type = 10;
pub const PJ_DNS_TYPE_WKS: pj_dns_type = 11;
pub const PJ_DNS_TYPE_PTR: pj_dns_type = 12;
pub const PJ_DNS_TYPE_HINFO: pj_dns_type = 13;
pub const PJ_DNS_TYPE_MINFO: pj_dns_type = 14;
pub const PJ_DNS_TYPE_MX: pj_dns_type = 15;
pub const PJ_DNS_TYPE_TXT: pj_dns_type = 16;
pub const PJ_DNS_TYPE_RP: pj_dns_type = 17;
pub const PJ_DNS_TYPE_AFSB: pj_dns_type = 18;
pub const PJ_DNS_TYPE_X25: pj_dns_type = 19;
pub const PJ_DNS_TYPE_ISDN: pj_dns_type = 20;
pub const PJ_DNS_TYPE_RT: pj_dns_type = 21;
pub const PJ_DNS_TYPE_NSAP: pj_dns_type = 22;
pub const PJ_DNS_TYPE_NSAP_PTR: pj_dns_type = 23;
pub const PJ_DNS_TYPE_SIG: pj_dns_type = 24;
pub const PJ_DNS_TYPE_KEY: pj_dns_type = 25;
pub const PJ_DNS_TYPE_PX: pj_dns_type = 26;
pub const PJ_DNS_TYPE_GPOS: pj_dns_type = 27;
pub const PJ_DNS_TYPE_AAAA: pj_dns_type = 28;
pub const PJ_DNS_TYPE_LOC: pj_dns_type = 29;
pub const PJ_DNS_TYPE_NXT: pj_dns_type = 30;
pub const PJ_DNS_TYPE_EID: pj_dns_type = 31;
pub const PJ_DNS_TYPE_NIMLOC: pj_dns_type = 32;
pub const PJ_DNS_TYPE_SRV: pj_dns_type = 33;
pub const PJ_DNS_TYPE_ATMA: pj_dns_type = 34;
pub const PJ_DNS_TYPE_NAPTR: pj_dns_type = 35;
pub const PJ_DNS_TYPE_KX: pj_dns_type = 36;
pub const PJ_DNS_TYPE_CERT: pj_dns_type = 37;
pub const PJ_DNS_TYPE_A6: pj_dns_type = 38;
pub const PJ_DNS_TYPE_DNAME: pj_dns_type = 39;
pub const PJ_DNS_TYPE_OPT: pj_dns_type = 41;
pub const PJ_DNS_TYPE_APL: pj_dns_type = 42;
pub const PJ_DNS_TYPE_DS: pj_dns_type = 43;
pub const PJ_DNS_TYPE_SSHFP: pj_dns_type = 44;
pub const PJ_DNS_TYPE_IPSECKEY: pj_dns_type = 45;
pub const PJ_DNS_TYPE_RRSIG: pj_dns_type = 46;
pub const PJ_DNS_TYPE_NSEC: pj_dns_type = 47;
pub const PJ_DNS_TYPE_DNSKEY: pj_dns_type = 48;
pub type pj_dns_type = u32;

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_dns_hdr {
    pub id: pj_uint16_t,
    pub flags: pj_uint16_t,
    pub qdcount: pj_uint16_t,
    pub anscount: pj_uint16_t,
    pub nscount: pj_uint16_t,
    pub arcount: pj_uint16_t,
}

pub const PJ_DNS_RCODE_FORMERR: pj_dns_rcode = 1;
pub const PJ_DNS_RCODE_SERVFAIL: pj_dns_rcode = 2;
pub const PJ_DNS_RCODE_NXDOMAIN: pj_dns_rcode = 3;
pub const PJ_DNS_RCODE_NOTIMPL: pj_dns_rcode = 4;
pub const PJ_DNS_RCODE_REFUSED: pj_dns_rcode = 5;
pub const PJ_DNS_RCODE_YXDOMAIN: pj_dns_rcode = 6;
pub const PJ_DNS_RCODE_YXRRSET: pj_dns_rcode = 7;
pub const PJ_DNS_RCODE_NXRRSET: pj_dns_rcode = 8;
pub const PJ_DNS_RCODE_NOTAUTH: pj_dns_rcode = 9;
pub const PJ_DNS_RCODE_NOTZONE: pj_dns_rcode = 10;
pub type pj_dns_rcode = u32;

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_dns_parsed_query {
    pub name: pj_str_t,
    pub type_: pj_uint16_t,
    pub dnsclass: pj_uint16_t,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_dns_parsed_rr {
    pub name: pj_str_t,
    pub type_: pj_uint16_t,
    pub dnsclass: pj_uint16_t,
    pub ttl: pj_uint32_t,
    pub rdlength: pj_uint16_t,
    pub data: *mut c_void,
    pub rdata: pj_dns_parsed_rr_rdata,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_dns_parsed_rr_rdata {
    pub srv: __BindgenUnionField<pj_dns_parsed_rr_rdata_srv>,
    pub cname: __BindgenUnionField<pj_dns_parsed_rr_rdata_cname>,
    pub ns: __BindgenUnionField<pj_dns_parsed_rr_rdata_ns>,
    pub ptr: __BindgenUnionField<pj_dns_parsed_rr_rdata_ptr>,
    pub a: __BindgenUnionField<pj_dns_parsed_rr_rdata_a>,
    pub aaaa: __BindgenUnionField<pj_dns_parsed_rr_rdata_aaaa>,
    pub bindgen_union_field: [u64; 3usize],
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_dns_parsed_rr_rdata_srv {
    pub prio: pj_uint16_t,
    pub weight: pj_uint16_t,
    pub port: pj_uint16_t,
    pub target: pj_str_t,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_dns_parsed_rr_rdata_cname {
    pub name: pj_str_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_dns_parsed_rr_rdata_ns {
    pub name: pj_str_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_dns_parsed_rr_rdata_ptr {
    pub name: pj_str_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_dns_parsed_rr_rdata_a {
    pub ip_addr: pj_in_addr,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_dns_parsed_rr_rdata_aaaa {
    pub ip_addr: pj_in6_addr,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_dns_parsed_packet {
    pub hdr: pj_dns_hdr,
    pub q: *mut pj_dns_parsed_query,
    pub ans: *mut pj_dns_parsed_rr,
    pub ns: *mut pj_dns_parsed_rr,
    pub arr: *mut pj_dns_parsed_rr,
}

pub const PJ_DNS_NO_QD: pj_dns_dup_options = 1;
pub const PJ_DNS_NO_ANS: pj_dns_dup_options = 2;
pub const PJ_DNS_NO_NS: pj_dns_dup_options = 4;
pub const PJ_DNS_NO_AR: pj_dns_dup_options = 8;
pub type pj_dns_dup_options = u32;



#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_resolver { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_async_query { _unused: [u8; 0] }

pub type pj_dns_callback = Option<
    unsafe extern "C" fn(user_data: *mut c_void, status: pj_status_t, response: *mut pj_dns_parsed_packet),
>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_settings {
    pub options: c_uint,
    pub qretr_delay: c_uint,
    pub qretr_count: c_uint,
    pub cache_max_ttl: c_uint,
    pub good_ns_ttl: c_uint,
    pub bad_ns_ttl: c_uint,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_dns_a_record {
    pub name: pj_str_t,
    pub alias: pj_str_t,
    pub addr_count: c_uint,
    pub addr: [pj_in_addr; 8usize],
    pub buf_: [c_char; 128usize],
}
#[repr(C)]
#[derive(Debug, Clone)]
pub struct pj_dns_addr_record {
    pub name: pj_str_t,
    pub alias: pj_str_t,
    pub addr_count: c_uint,
    pub addr: [pj_dns_addr_record__bindgen_ty_1; 8usize],
    pub buf_: [c_char; 128usize],
}
#[repr(C)]
#[derive(Debug, Clone)]
pub struct pj_dns_addr_record__bindgen_ty_1 {
    pub af: c_int,
    pub ip: pj_dns_addr_record__bindgen_ty_1__bindgen_ty_1,
}

#[repr(C)]
#[derive(Debug, Clone)]
pub struct pj_dns_addr_record__bindgen_ty_1__bindgen_ty_1 {
    pub v4: __BindgenUnionField<pj_in_addr>,
    pub v6: __BindgenUnionField<pj_in6_addr>,
    pub bindgen_union_field: [u32; 4usize],
}

pub const PJ_DNS_SRV_FALLBACK_A: pj_dns_srv_option = 1;
pub const PJ_DNS_SRV_FALLBACK_AAAA: pj_dns_srv_option = 2;
pub const PJ_DNS_SRV_RESOLVE_AAAA: pj_dns_srv_option = 4;
pub const PJ_DNS_SRV_RESOLVE_AAAA_ONLY: pj_dns_srv_option = 8;
pub type pj_dns_srv_option = u32;

#[repr(C)]
#[derive(Debug, Clone)]
pub struct pj_dns_srv_record {
    pub count: c_uint,
    pub entry: [pj_dns_srv_record__bindgen_ty_1; 8usize],
}

#[repr(C)]
#[derive(Debug, Clone)]
pub struct pj_dns_srv_record__bindgen_ty_1 {
    pub priority: c_uint,
    pub weight: c_uint,
    pub port: pj_uint16_t,
    pub server: pj_dns_addr_record,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_srv_async_query { _unused: [u8; 0] }

pub type pj_dns_srv_resolver_cb = Option<unsafe extern "C" fn(user_data: *mut c_void, status: pj_status_t, rec: *const pj_dns_srv_record)>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_dns_server { _unused: [u8; 0] }

pub type pj_cis_elem_t = pj_uint32_t;

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_cis_buf_t {
    pub cis_buf: [pj_cis_elem_t; 256usize],
    pub use_mask: pj_cis_elem_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cis_t {
    pub cis_buf: *mut pj_cis_elem_t,
    pub cis_id: c_int,
}


pub const PJ_SCAN_AUTOSKIP_WS: u32 = 1;
pub const PJ_SCAN_AUTOSKIP_WS_HEADER: u32 = 3;
pub const PJ_SCAN_AUTOSKIP_NEWLINE: u32 = 4;
pub type _bindgen_ty_12 = u32;

pub type pj_syn_err_func_ptr = Option<unsafe extern "C" fn(scanner: *mut pj_scanner)>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_scanner {
    pub begin: *mut c_char,
    pub end: *mut c_char,
    pub curptr: *mut c_char,
    pub line: c_int,
    pub start_line: *mut c_char,
    pub skip_ws: c_int,
    pub callback: pj_syn_err_func_ptr,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_scan_state {
    pub curptr: *mut c_char,
    pub line: c_int,
    pub start_line: *mut c_char,
}



#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_xml_attr {
    pub prev: *mut pj_xml_attr,
    pub next: *mut pj_xml_attr,
    pub name: pj_str_t,
    pub value: pj_str_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_xml_node_head {
    pub prev: *mut pj_xml_node,
    pub next: *mut pj_xml_node,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_xml_node {
    pub prev: *mut pj_xml_node,
    pub next: *mut pj_xml_node,
    pub name: pj_str_t,
    pub attr_head: pj_xml_attr,
    pub node_head: pj_xml_node_head,
    pub content: pj_str_t,
}


pub const PJ_JSON_VAL_NULL: pj_json_val_type = 0;
pub const PJ_JSON_VAL_BOOL: pj_json_val_type = 1;
pub const PJ_JSON_VAL_NUMBER: pj_json_val_type = 2;
pub const PJ_JSON_VAL_STRING: pj_json_val_type = 3;
pub const PJ_JSON_VAL_ARRAY: pj_json_val_type = 4;
pub const PJ_JSON_VAL_OBJ: pj_json_val_type = 5;
pub type pj_json_val_type = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_json_list {
    pub prev: *mut pj_json_elem,
    pub next: *mut pj_json_elem,
}

#[repr(C)]
#[derive(Debug, Clone)]
pub struct pj_json_elem {
    pub prev: *mut pj_json_elem,
    pub next: *mut pj_json_elem,
    pub name: pj_str_t,
    pub type_: pj_json_val_type,
    pub value: pj_json_elem__bindgen_ty_1,
}

#[repr(C)]
#[derive(Debug, Clone)]
pub struct pj_json_elem__bindgen_ty_1 {
    pub is_true: __BindgenUnionField<pj_bool_t>,
    pub num: __BindgenUnionField<f32>,
    pub str_: __BindgenUnionField<pj_str_t>,
    pub children: __BindgenUnionField<pj_json_list>,
    pub bindgen_union_field: [u64; 2usize],
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_json_err_info {
    pub line: c_uint,
    pub col: c_uint,
    pub err_char: c_int,
}

pub type pj_json_writer = Option<
    unsafe extern "C" fn(s: *const c_char, size: c_uint, user_data: *mut c_void) -> pj_status_t,
>;

pub const PJSTUN_BINDING_REQUEST: pjstun_msg_type = 1;
pub const PJSTUN_BINDING_RESPONSE: pjstun_msg_type = 257;
pub const PJSTUN_BINDING_ERROR_RESPONSE: pjstun_msg_type = 273;
pub const PJSTUN_SHARED_SECRET_REQUEST: pjstun_msg_type = 2;
pub const PJSTUN_SHARED_SECRET_RESPONSE: pjstun_msg_type = 258;
pub const PJSTUN_SHARED_SECRET_ERROR_RESPONSE: pjstun_msg_type = 274;
pub type pjstun_msg_type = u32;

pub const PJSTUN_ATTR_MAPPED_ADDR: pjstun_attr_type = 1;
pub const PJSTUN_ATTR_RESPONSE_ADDR: pjstun_attr_type = 2;
pub const PJSTUN_ATTR_CHANGE_REQUEST: pjstun_attr_type = 3;
pub const PJSTUN_ATTR_SOURCE_ADDR: pjstun_attr_type = 4;
pub const PJSTUN_ATTR_CHANGED_ADDR: pjstun_attr_type = 5;
pub const PJSTUN_ATTR_USERNAME: pjstun_attr_type = 6;
pub const PJSTUN_ATTR_PASSWORD: pjstun_attr_type = 7;
pub const PJSTUN_ATTR_MESSAGE_INTEGRITY: pjstun_attr_type = 8;
pub const PJSTUN_ATTR_ERROR_CODE: pjstun_attr_type = 9;
pub const PJSTUN_ATTR_UNKNOWN_ATTRIBUTES: pjstun_attr_type = 10;
pub const PJSTUN_ATTR_REFLECTED_FROM: pjstun_attr_type = 11;
pub const PJSTUN_ATTR_XOR_MAPPED_ADDR: pjstun_attr_type = 32;
pub type pjstun_attr_type = u32;

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pjstun_msg_hdr {
    pub type_: pj_uint16_t,
    pub length: pj_uint16_t,
    pub tsx: [pj_uint32_t; 4usize],
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pjstun_attr_hdr {
    pub type_: pj_uint16_t,
    pub length: pj_uint16_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pjstun_mapped_addr_attr {
    pub hdr: pjstun_attr_hdr,
    pub ignored: pj_uint8_t,
    pub family: pj_uint8_t,
    pub port: pj_uint16_t,
    pub addr: pj_uint32_t,
}

pub type pjstun_response_addr_attr = pjstun_mapped_addr_attr;
pub type pjstun_changed_addr_attr = pjstun_mapped_addr_attr;
pub type pjstun_src_addr_attr = pjstun_mapped_addr_attr;
pub type pjstun_reflected_form_attr = pjstun_mapped_addr_attr;

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pjstun_change_request_attr {
    pub hdr: pjstun_attr_hdr,
    pub value: pj_uint32_t,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pjstun_username_attr {
    pub hdr: pjstun_attr_hdr,
    pub value: [pj_uint32_t; 1usize],
}
pub type pjstun_password_attr = pjstun_username_attr;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pjstun_error_code_attr {
    pub hdr: pjstun_attr_hdr,
    pub ignored: pj_uint16_t,
    pub err_class: pj_uint8_t,
    pub number: pj_uint8_t,
    pub reason: [c_char; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pjstun_msg {
    pub hdr: *mut pjstun_msg_hdr,
    pub attr_count: c_int,
    pub attr: [*mut pjstun_attr_hdr; 16usize],
}



#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pjstun_setting {
    pub use_stun2: pj_bool_t,
    pub af: c_int,
    pub srv1: pj_str_t,
    pub port1: c_int,
    pub srv2: pj_str_t,
    pub port2: c_int,
}



pub const PJ_PCAP_LINK_TYPE_ETH: pj_pcap_link_type = 1;
pub type pj_pcap_link_type = u32;
pub const PJ_PCAP_PROTO_TYPE_UDP: pj_pcap_proto_type = 17;
pub type pj_pcap_proto_type = u32;
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_pcap_udp_hdr {
    pub src_port: pj_uint16_t,
    pub dst_port: pj_uint16_t,
    pub len: pj_uint16_t,
    pub csum: pj_uint16_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_pcap_filter {
    pub link: pj_pcap_link_type,
    pub proto: pj_pcap_proto_type,
    pub ip_src: pj_uint32_t,
    pub ip_dst: pj_uint32_t,
    pub src_port: pj_uint16_t,
    pub dst_port: pj_uint16_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_pcap_file { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_http_req { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_http_header_elmt {
    pub name: pj_str_t,
    pub value: pj_str_t,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_http_headers {
    pub count: c_uint,
    pub header: [pj_http_header_elmt; 32usize],
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_http_auth_cred {
    pub scheme: pj_str_t,
    pub realm: pj_str_t,
    pub username: pj_str_t,
    pub data_type: c_uint,
    pub data: pj_str_t,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_http_req_param {
    pub addr_family: c_int,
    pub method: pj_str_t,
    pub version: pj_str_t,
    pub timeout: pj_time_val,
    pub user_data: *mut c_void,
    pub headers: pj_http_headers,
    pub reqdata: pj_http_req_param_pj_http_reqdata,
    pub auth_cred: pj_http_auth_cred,
    pub source_port_range_start: pj_uint16_t,
    pub source_port_range_size: pj_uint16_t,
    pub max_retries: pj_uint16_t,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_http_req_param_pj_http_reqdata {
    pub data: *mut c_void,
    pub size: pj_size_t,
    pub total_size: pj_size_t,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_http_auth_chal {
    pub scheme: pj_str_t,
    pub realm: pj_str_t,
    pub domain: pj_str_t,
    pub nonce: pj_str_t,
    pub opaque: pj_str_t,
    pub stale: c_int,
    pub algorithm: pj_str_t,
    pub qop: pj_str_t,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_http_resp {
    pub version: pj_str_t,
    pub status_code: pj_uint16_t,
    pub reason: pj_str_t,
    pub headers: pj_http_headers,
    pub auth_chal: pj_http_auth_chal,
    pub content_length: pj_int32_t,
    pub data: *mut c_void,
    pub size: pj_size_t,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_http_url {
    pub username: pj_str_t,
    pub passwd: pj_str_t,
    pub protocol: pj_str_t,
    pub host: pj_str_t,
    pub port: pj_uint16_t,
    pub path: pj_str_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_http_req_callback {
    pub on_response: Option<
        unsafe extern "C" fn(http_req: *mut pj_http_req, resp: *const pj_http_resp),
    >,
    pub on_send_data: Option<
        unsafe extern "C" fn(http_req: *mut pj_http_req, data: *mut *mut c_void, size: *mut pj_size_t),
    >,
    pub on_data_read: Option<
        unsafe extern "C" fn(http_req: *mut pj_http_req, data: *mut c_void, size: pj_size_t),
    >,
    pub on_complete: Option<
        unsafe extern "C" fn(http_req: *mut pj_http_req, status: pj_status_t, resp: *const pj_http_resp),
    >,
}


#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_t { _unused: [u8; 0] }


pub type pj_cli_cmd_id = c_int;

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_cli_cfg {
    pub name: pj_str_t,
    pub title: pj_str_t,
    pub pf: *mut pj_pool_factory,
}

pub type pj_cli_arg_id = c_int;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_cmd_spec { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_arg_spec { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_cli_cmd_val {
    pub sess: *mut pj_cli_sess,
    pub cmd: *const pj_cli_cmd_spec,
    pub argc: c_int,
    pub argv: [pj_str_t; 8usize],
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_cli_hint_info {
    pub name: pj_str_t,
    pub type_: pj_str_t,
    pub desc: pj_str_t,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_cli_exec_info {
    pub err_pos: c_int,
    pub cmd_id: pj_cli_cmd_id,
    pub cmd_ret: pj_status_t,
    pub hint_cnt: c_uint,
    pub hint: [pj_cli_hint_info; 32usize],
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_cli_arg_choice_val {
    pub value: pj_str_t,
    pub desc: pj_str_t,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_cli_dyn_choice_param {
    pub sess: *mut pj_cli_sess,
    pub cmd: *mut pj_cli_cmd_spec,
    pub arg_id: pj_cli_arg_id,
    pub max_cnt: c_uint,
    pub pool: *mut pj_pool_t,
    pub cnt: c_uint,
    pub choice: [pj_cli_arg_choice_val; 64usize],
}

pub type pj_cli_get_dyn_choice = Option<unsafe extern "C" fn(param: *mut pj_cli_dyn_choice_param)>;
pub type pj_cli_cmd_handler = Option<unsafe extern "C" fn(cval: *mut pj_cli_cmd_val) -> pj_status_t>;


pub const PJ_CLI_CONSOLE_FRONT_END: pj_cli_front_end_type = 0;
pub const PJ_CLI_TELNET_FRONT_END: pj_cli_front_end_type = 1;
pub const PJ_CLI_HTTP_FRONT_END: pj_cli_front_end_type = 2;
pub const PJ_CLI_GUI_FRONT_END: pj_cli_front_end_type = 3;
pub type pj_cli_front_end_type = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_front_end_op {
    pub on_write_log: Option<unsafe extern "C" fn(fe: *mut pj_cli_front_end, level: c_int, data: *const c_char, len: pj_size_t)>,
    pub on_quit: Option<unsafe extern "C" fn(fe: *mut pj_cli_front_end, req: *mut pj_cli_sess)>,
    pub on_destroy: Option<unsafe extern "C" fn(fe: *mut pj_cli_front_end)>
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_front_end {
    pub prev: *mut pj_cli_front_end,
    pub next: *mut pj_cli_front_end,
    pub type_: pj_cli_front_end_type,
    pub cli: *mut pj_cli_t,
    pub op: *mut pj_cli_front_end_op,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pj_cli_sess_op {
    pub destroy: Option<unsafe extern "C" fn(sess: *mut pj_cli_sess)>,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_cli_sess {
    pub prev: *mut pj_cli_sess,
    pub next: *mut pj_cli_sess,
    pub fe: *mut pj_cli_front_end,
    pub op: *mut pj_cli_sess_op,
    pub info: pj_str_t,
    pub log_level: c_int,
}
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_cli_console_cfg {
    pub log_level: c_int,
    pub prompt_str: pj_str_t,
    pub quit_command: pj_str_t,
}



#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_cli_telnet_info {
    pub ip_address: pj_str_t,
    pub port: pj_uint16_t,
    pub buf_: [c_char; 32usize],
}

pub type pj_cli_telnet_on_started = Option<unsafe extern "C" fn(status: pj_status_t)>;

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct pj_cli_telnet_cfg {
    pub port: pj_uint16_t,
    pub ioqueue: *mut pj_ioqueue_t,
    pub log_level: c_int,
    pub passwd: pj_str_t,
    pub welcome_msg: pj_str_t,
    pub prompt_str: pj_str_t,
    pub on_started: pj_cli_telnet_on_started,
}

extern "C" {
    pub static mut pj_optind: c_int;
    pub static mut pj_optopt: c_int;
    pub fn pjlib_util_init() -> pj_status_t;
    pub fn pj_getopt(argc: c_int, argv: *const *mut c_char, shortopts: *const c_char) -> c_int;
    pub fn pj_getopt_long(argc: c_int, argv: *const *mut c_char, options: *const c_char, longopts: *const pj_getopt_option, longind: *mut c_int) -> c_int;
    pub fn pj_base64_encode(input: *const pj_uint8_t, in_len: c_int, output: *mut c_char, out_len: *mut c_int) -> pj_status_t;
    pub fn pj_base64_decode(input: *const pj_str_t, out: *mut pj_uint8_t, out_len: *mut c_int) -> pj_status_t;
    pub fn pj_crc32_init(ctx: *mut pj_crc32_context);
    pub fn pj_crc32_update(ctx: *mut pj_crc32_context, data: *const pj_uint8_t, nbytes: pj_size_t) -> pj_uint32_t;
    pub fn pj_crc32_final(ctx: *mut pj_crc32_context) -> pj_uint32_t;
    pub fn pj_crc32_calc(data: *const pj_uint8_t, nbytes: pj_size_t) -> pj_uint32_t;
    pub fn pj_md5_init(pms: *mut pj_md5_context);
    pub fn pj_md5_update(pms: *mut pj_md5_context, data: *const pj_uint8_t, nbytes: c_uint);
    pub fn pj_md5_final(pms: *mut pj_md5_context, digest: *mut pj_uint8_t);
    pub fn pj_hmac_md5(input: *const pj_uint8_t, input_len: c_uint, key: *const pj_uint8_t, key_len: c_uint, digest: *mut pj_uint8_t);
    pub fn pj_hmac_md5_init(hctx: *mut pj_hmac_md5_context, key: *const pj_uint8_t, key_len: c_uint);
    pub fn pj_hmac_md5_update(hctx: *mut pj_hmac_md5_context, input: *const pj_uint8_t, input_len: c_uint);
    pub fn pj_hmac_md5_final(hctx: *mut pj_hmac_md5_context, digest: *mut pj_uint8_t);
    pub fn pj_hmac_sha1(input: *const pj_uint8_t, input_len: c_uint, key: *const pj_uint8_t, key_len: c_uint, digest: *mut pj_uint8_t);
    pub fn pj_hmac_sha1_init(hctx: *mut pj_hmac_sha1_context, key: *const pj_uint8_t, key_len: c_uint);
    pub fn pj_hmac_sha1_update(hctx: *mut pj_hmac_sha1_context, input: *const pj_uint8_t, input_len: c_uint);
    pub fn pj_hmac_sha1_final(hctx: *mut pj_hmac_sha1_context, digest: *mut pj_uint8_t);
    pub fn pj_sha1_init(ctx: *mut pj_sha1_context);
    pub fn pj_sha1_update(ctx: *mut pj_sha1_context, data: *const pj_uint8_t, nbytes: pj_size_t);
    pub fn pj_sha1_final(ctx: *mut pj_sha1_context, digest: *mut pj_uint8_t);
    pub fn pj_dns_make_query(packet: *mut c_void, size: *mut c_uint, id: pj_uint16_t, qtype: c_int, name: *const pj_str_t) -> pj_status_t;
    pub fn pj_dns_parse_packet(pool: *mut pj_pool_t, packet: *const c_void, size: c_uint, p_res: *mut *mut pj_dns_parsed_packet) -> pj_status_t;
    pub fn pj_dns_packet_dup(pool: *mut pj_pool_t, p: *const pj_dns_parsed_packet, options: c_uint, p_dst: *mut *mut pj_dns_parsed_packet);
    pub fn pj_dns_get_type_name(type_: c_int) -> *const c_char;
    pub fn pj_dns_init_srv_rr(rec: *mut pj_dns_parsed_rr, res_name: *const pj_str_t, dnsclass: c_uint, ttl: c_uint, prio: c_uint, weight: c_uint, port: c_uint, target: *const pj_str_t);
    pub fn pj_dns_init_cname_rr(rec: *mut pj_dns_parsed_rr, res_name: *const pj_str_t, dnsclass: c_uint, ttl: c_uint, name: *const pj_str_t);
    pub fn pj_dns_init_a_rr(rec: *mut pj_dns_parsed_rr, res_name: *const pj_str_t, dnsclass: c_uint, ttl: c_uint, ip_addr: *const pj_in_addr);
    pub fn pj_dns_init_aaaa_rr(rec: *mut pj_dns_parsed_rr, res_name: *const pj_str_t, dnsclass: c_uint, ttl: c_uint, ip_addr: *const pj_in6_addr);
    pub fn pj_dns_dump_packet(res: *const pj_dns_parsed_packet);
    pub fn pj_dns_settings_default(s: *mut pj_dns_settings);
    pub fn pj_dns_resolver_create(pf: *mut pj_pool_factory, name: *const c_char, options: c_uint, timer: *mut pj_timer_heap_t, ioqueue: *mut pj_ioqueue_t, p_resolver: *mut *mut pj_dns_resolver) -> pj_status_t;
    pub fn pj_dns_resolver_set_ns( resolver: *mut pj_dns_resolver, count: c_uint, servers: *const pj_str_t, ports: *const pj_uint16_t) -> pj_status_t;
    pub fn pj_dns_resolver_get_settings(resolver: *mut pj_dns_resolver, st: *mut pj_dns_settings) -> pj_status_t;
    pub fn pj_dns_resolver_set_settings(resolver: *mut pj_dns_resolver, st: *const pj_dns_settings) -> pj_status_t;
    pub fn pj_dns_resolver_handle_events(resolver: *mut pj_dns_resolver, timeout: *const pj_time_val);
    pub fn pj_dns_resolver_destroy(resolver: *mut pj_dns_resolver, notify: pj_bool_t) -> pj_status_t;
    pub fn pj_dns_resolver_start_query(resolver: *mut pj_dns_resolver, name: *const pj_str_t, type_: c_int, options: c_uint, cb: pj_dns_callback, user_data: *mut c_void, p_query: *mut *mut pj_dns_async_query) -> pj_status_t;
    pub fn pj_dns_resolver_cancel_query(query: *mut pj_dns_async_query, notify: pj_bool_t) -> pj_status_t;
    pub fn pj_dns_parse_a_response(pkt: *const pj_dns_parsed_packet, rec: *mut pj_dns_a_record) -> pj_status_t;
    pub fn pj_dns_parse_addr_response(pkt: *const pj_dns_parsed_packet, rec: *mut pj_dns_addr_record) -> pj_status_t;
    pub fn pj_dns_resolver_add_entry(resolver: *mut pj_dns_resolver, pkt: *const pj_dns_parsed_packet, set_ttl: pj_bool_t) -> pj_status_t;
    pub fn pj_dns_resolver_get_cached_count(resolver: *mut pj_dns_resolver) -> c_uint;
    pub fn pj_dns_resolver_dump(resolver: *mut pj_dns_resolver, detail: pj_bool_t);
    pub fn pj_dns_srv_resolve(domain_name: *const pj_str_t, res_name: *const pj_str_t, def_port: c_uint, pool: *mut pj_pool_t, resolver: *mut pj_dns_resolver, option: c_uint, token: *mut c_void, cb: pj_dns_srv_resolver_cb, p_query: *mut *mut pj_dns_srv_async_query) -> pj_status_t;
    pub fn pj_dns_srv_cancel_query(query: *mut pj_dns_srv_async_query, notify: pj_bool_t) -> pj_status_t;
    pub fn pj_dns_server_create(pf: *mut pj_pool_factory, ioqueue: *mut pj_ioqueue_t, af: c_int, port: c_uint, flags: c_uint, p_srv: *mut *mut pj_dns_server) -> pj_status_t;
    pub fn pj_dns_server_destroy(srv: *mut pj_dns_server) -> pj_status_t;
    pub fn pj_dns_server_add_rec(srv: *mut pj_dns_server, count: c_uint, rr: *const pj_dns_parsed_rr) -> pj_status_t;
    pub fn pj_dns_server_del_rec(srv: *mut pj_dns_server, dns_class: c_int, type_: pj_dns_type, name: *const pj_str_t) -> pj_status_t;
    pub fn pj_cis_buf_init(cs_buf: *mut pj_cis_buf_t);
    pub fn pj_cis_init(cs_buf: *mut pj_cis_buf_t, cis: *mut pj_cis_t) -> pj_status_t;
    pub fn pj_cis_dup(new_cis: *mut pj_cis_t, existing: *mut pj_cis_t) -> pj_status_t;
    pub fn pj_cis_add_range(cis: *mut pj_cis_t, cstart: c_int, cend: c_int);
    pub fn pj_cis_add_alpha(cis: *mut pj_cis_t);
    pub fn pj_cis_add_num(cis: *mut pj_cis_t);
    pub fn pj_cis_add_str(cis: *mut pj_cis_t, str_: *const c_char);
    pub fn pj_cis_add_cis(cis: *mut pj_cis_t, rhs: *const pj_cis_t);
    pub fn pj_cis_del_range(cis: *mut pj_cis_t, cstart: c_int, cend: c_int);
    pub fn pj_cis_del_str(cis: *mut pj_cis_t, str_: *const c_char);
    pub fn pj_cis_invert(cis: *mut pj_cis_t);
    pub fn pj_scan_init(scanner: *mut pj_scanner, bufstart: *mut c_char, buflen: pj_size_t, options: c_uint, callback: pj_syn_err_func_ptr);
    pub fn pj_scan_fini(scanner: *mut pj_scanner);
    pub fn pj_scan_peek(scanner: *mut pj_scanner, spec: *const pj_cis_t, out: *mut pj_str_t) -> c_int;
    pub fn pj_scan_peek_n(scanner: *mut pj_scanner, len: pj_size_t, out: *mut pj_str_t) -> c_int;
    pub fn pj_scan_peek_until(scanner: *mut pj_scanner, spec: *const pj_cis_t, out: *mut pj_str_t) -> c_int;
    pub fn pj_scan_get(scanner: *mut pj_scanner, spec: *const pj_cis_t, out: *mut pj_str_t);
    pub fn pj_scan_get_unescape(scanner: *mut pj_scanner, spec: *const pj_cis_t, out: *mut pj_str_t);
    pub fn pj_scan_get_quote(scanner: *mut pj_scanner, begin_quote: c_int, end_quote: c_int, out: *mut pj_str_t);
    pub fn pj_scan_get_quotes(scanner: *mut pj_scanner, begin_quotes: *const c_char, end_quotes: *const c_char, qsize: c_int, out: *mut pj_str_t);
    pub fn pj_scan_get_n(scanner: *mut pj_scanner, N: c_uint, out: *mut pj_str_t);
    pub fn pj_scan_get_char(scanner: *mut pj_scanner) -> c_int;
    pub fn pj_scan_get_until(scanner: *mut pj_scanner, spec: *const pj_cis_t, out: *mut pj_str_t);
    pub fn pj_scan_get_until_ch(scanner: *mut pj_scanner, until_char: c_int, out: *mut pj_str_t);
    pub fn pj_scan_get_until_chr(scanner: *mut pj_scanner, until_spec: *const c_char, out: *mut pj_str_t);
    pub fn pj_scan_advance_n(scanner: *mut pj_scanner, N: c_uint, skip: pj_bool_t);
    pub fn pj_scan_strcmp( scanner: *mut pj_scanner, s: *const c_char, len: c_int) -> c_int;
    pub fn pj_scan_stricmp(scanner: *mut pj_scanner, s: *const c_char, len: c_int) -> c_int;
    pub fn pj_scan_stricmp_alnum(scanner: *mut pj_scanner, s: *const c_char, len: c_int) -> c_int;
    pub fn pj_scan_get_newline(scanner: *mut pj_scanner);
    pub fn pj_scan_skip_whitespace(scanner: *mut pj_scanner);
    pub fn pj_scan_skip_line(scanner: *mut pj_scanner);
    pub fn pj_scan_save_state(scanner: *const pj_scanner, state: *mut pj_scan_state);
    pub fn pj_scan_restore_state(scanner: *mut pj_scanner, state: *mut pj_scan_state);
    pub fn pj_str_unescape(pool: *mut pj_pool_t, src: *const pj_str_t) -> pj_str_t;
    pub fn pj_strcpy_unescape(dst: *mut pj_str_t, src: *const pj_str_t) -> *mut pj_str_t;
    pub fn pj_strncpy_escape(dst: *mut pj_str_t, src: *const pj_str_t, max: pj_ssize_t, unres: *const pj_cis_t) -> *mut pj_str_t;
    pub fn pj_strncpy2_escape(dst: *mut c_char, src: *const pj_str_t, max: pj_ssize_t, unres: *const pj_cis_t) -> pj_ssize_t;
    pub fn pj_xml_parse(pool: *mut pj_pool_t, msg: *mut c_char, len: pj_size_t) -> *mut pj_xml_node;
    pub fn pj_xml_print(node: *const pj_xml_node, buf: *mut c_char, len: pj_size_t, prolog: pj_bool_t) -> c_int;
    pub fn pj_xml_clone(pool: *mut pj_pool_t, rhs: *const pj_xml_node) -> *mut pj_xml_node;
    pub fn pj_xml_node_new(pool: *mut pj_pool_t, name: *const pj_str_t) -> *mut pj_xml_node;
    pub fn pj_xml_attr_new(pool: *mut pj_pool_t, name: *const pj_str_t, value: *const pj_str_t) -> *mut pj_xml_attr;
    pub fn pj_xml_add_node(parent: *mut pj_xml_node, node: *mut pj_xml_node);
    pub fn pj_xml_add_attr(node: *mut pj_xml_node, attr: *mut pj_xml_attr);
    pub fn pj_xml_find_node(parent: *const pj_xml_node, name: *const pj_str_t) -> *mut pj_xml_node;
    pub fn pj_xml_find_next_node(parent: *const pj_xml_node, node: *const pj_xml_node, name: *const pj_str_t) -> *mut pj_xml_node;
    pub fn pj_xml_find_node_rec(parent: *const pj_xml_node, name: *const pj_str_t) -> *mut pj_xml_node;
    pub fn pj_xml_find_attr(node: *const pj_xml_node, name: *const pj_str_t, value: *const pj_str_t) -> *mut pj_xml_attr;
    pub fn pj_xml_find(parent: *const pj_xml_node, name: *const pj_str_t, data: *const c_void,
        match_: Option<unsafe extern "C" fn(arg1: *const pj_xml_node, arg2: *const c_void) -> pj_bool_t>) -> *mut pj_xml_node;
    pub fn pj_xml_find_rec(parent: *const pj_xml_node, name: *const pj_str_t, data: *const c_void,
        match_: Option<unsafe extern "C" fn(arg1: *const pj_xml_node, arg2: *const c_void) -> pj_bool_t>) -> *mut pj_xml_node;
    pub fn pj_json_elem_null(el: *mut pj_json_elem, name: *mut pj_str_t);
    pub fn pj_json_elem_bool(el: *mut pj_json_elem, name: *mut pj_str_t, val: pj_bool_t);
    pub fn pj_json_elem_number(el: *mut pj_json_elem, name: *mut pj_str_t, val: f32);
    pub fn pj_json_elem_string(el: *mut pj_json_elem, name: *mut pj_str_t, val: *mut pj_str_t);
    pub fn pj_json_elem_array(el: *mut pj_json_elem, name: *mut pj_str_t);
    pub fn pj_json_elem_obj(el: *mut pj_json_elem, name: *mut pj_str_t);
    pub fn pj_json_elem_add(el: *mut pj_json_elem, child: *mut pj_json_elem);
    pub fn pj_json_parse(pool: *mut pj_pool_t, buffer: *mut c_char, size: *mut c_uint, err_info: *mut pj_json_err_info) -> *mut pj_json_elem;
    pub fn pj_json_write(elem: *const pj_json_elem, buffer: *mut c_char, size: *mut c_uint) -> pj_status_t;
    pub fn pj_json_writef(elem: *const pj_json_elem, writer: pj_json_writer, user_data: *mut c_void) -> pj_status_t;
    pub fn pjstun_create_bind_req(pool: *mut pj_pool_t, msg: *mut *mut c_void, len: *mut pj_size_t, id_hi: pj_uint32_t, id_lo: pj_uint32_t) -> pj_status_t;
    pub fn pjstun_parse_msg(buf: *mut c_void, len: pj_size_t, msg: *mut pjstun_msg) -> pj_status_t;
    pub fn pjstun_msg_find_attr(msg: *mut pjstun_msg, t: pjstun_attr_type) -> *mut c_void;
    pub fn pjstun_get_mapped_addr(pf: *mut pj_pool_factory, sock_cnt: c_int, sock: *mut pj_sock_t, srv1: *const pj_str_t, port1: c_int, srv2: *const pj_str_t, port2: c_int, mapped_addr: *mut pj_sockaddr_in) -> pj_status_t;
    pub fn pjstun_get_mapped_addr2(pf: *mut pj_pool_factory, opt: *const pjstun_setting, sock_cnt: c_int, sock: *mut pj_sock_t, mapped_addr: *mut pj_sockaddr_in) -> pj_status_t;
    pub fn pj_pcap_filter_default(filter: *mut pj_pcap_filter);
    pub fn pj_pcap_open(pool: *mut pj_pool_t, path: *const c_char, p_file: *mut *mut pj_pcap_file) -> pj_status_t;
    pub fn pj_pcap_close(file: *mut pj_pcap_file) -> pj_status_t;
    pub fn pj_pcap_set_filter(file: *mut pj_pcap_file, filter: *const pj_pcap_filter) -> pj_status_t;
    pub fn pj_pcap_read_udp(file: *mut pj_pcap_file, udp_hdr: *mut pj_pcap_udp_hdr, udp_payload: *mut pj_uint8_t, udp_payload_size: *mut pj_size_t) -> pj_status_t;
    pub fn pj_http_req_param_default(param: *mut pj_http_req_param);
    pub fn pj_http_headers_add_elmt(headers: *mut pj_http_headers, name: *mut pj_str_t, val: *mut pj_str_t) -> pj_status_t;
    pub fn pj_http_headers_add_elmt2(headers: *mut pj_http_headers, name: *mut c_char, val: *mut c_char) -> pj_status_t;
    pub fn pj_http_req_parse_url(url: *const pj_str_t, hurl: *mut pj_http_url) -> pj_status_t;
    pub fn pj_http_req_create(pool: *mut pj_pool_t, url: *const pj_str_t, timer: *mut pj_timer_heap_t, ioqueue: *mut pj_ioqueue_t, param: *const pj_http_req_param, hcb: *const pj_http_req_callback, http_req: *mut *mut pj_http_req) -> pj_status_t;
    pub fn pj_http_req_set_timeout(http_req: *mut pj_http_req, timeout: *const pj_time_val);
    pub fn pj_http_req_start(http_req: *mut pj_http_req) -> pj_status_t;
    pub fn pj_http_req_cancel(http_req: *mut pj_http_req, notify: pj_bool_t) -> pj_status_t;
    pub fn pj_http_req_destroy(http_req: *mut pj_http_req) -> pj_status_t;
    pub fn pj_http_req_is_running(http_req: *const pj_http_req) -> pj_bool_t;
    pub fn pj_http_req_get_user_data(http_req: *mut pj_http_req) -> *mut c_void;
    pub fn pj_cli_write_log(cli: *mut pj_cli_t, level: c_int, buffer: *const c_char, len: c_int);
    pub fn pj_cli_create(cfg: *mut pj_cli_cfg, p_cli: *mut *mut pj_cli_t) -> pj_status_t;
    pub fn pj_cli_get_cmd_id(cmd: *const pj_cli_cmd_spec) -> pj_cli_cmd_id;
    pub fn pj_cli_get_param(cli: *mut pj_cli_t) -> *mut pj_cli_cfg;
    pub fn pj_cli_quit(cli: *mut pj_cli_t, req: *mut pj_cli_sess, restart: pj_bool_t);
    pub fn pj_cli_is_quitting(cli: *mut pj_cli_t) -> pj_bool_t;
    pub fn pj_cli_is_restarting(cli: *mut pj_cli_t) -> pj_bool_t;
    pub fn pj_cli_destroy(cli: *mut pj_cli_t);
    pub fn pj_cli_cfg_default(param: *mut pj_cli_cfg);
    pub fn pj_cli_register_front_end(cli: *mut pj_cli_t, fe: *mut pj_cli_front_end);
    pub fn pj_cli_add_cmd_from_xml(cli: *mut pj_cli_t, group: *mut pj_cli_cmd_spec, xml: *const pj_str_t, handler: pj_cli_cmd_handler, p_cmd: *mut *mut pj_cli_cmd_spec, get_choice: pj_cli_get_dyn_choice) -> pj_status_t;
    pub fn pj_cli_exec_info_default(param: *mut pj_cli_exec_info);
    pub fn pj_cli_sess_write_msg(sess: *mut pj_cli_sess, buffer: *const c_char, len: pj_size_t);
    pub fn pj_cli_sess_parse(sess: *mut pj_cli_sess, cmdline: *mut c_char, val: *mut pj_cli_cmd_val, pool: *mut pj_pool_t, info: *mut pj_cli_exec_info) -> pj_status_t;
    pub fn pj_cli_sess_end_session(sess: *mut pj_cli_sess);
    pub fn pj_cli_sess_exec(sess: *mut pj_cli_sess, cmdline: *mut c_char, pool: *mut pj_pool_t, info: *mut pj_cli_exec_info) -> pj_status_t;
    pub fn pj_cli_console_cfg_default(param: *mut pj_cli_console_cfg);
    pub fn pj_cli_console_create(cli: *mut pj_cli_t, param: *const pj_cli_console_cfg, p_sess: *mut *mut pj_cli_sess, p_fe: *mut *mut pj_cli_front_end) -> pj_status_t;
    pub fn pj_cli_console_process(sess: *mut pj_cli_sess, buf: *mut c_char, maxlen: c_uint) -> pj_status_t;
    pub fn pj_cli_telnet_cfg_default(param: *mut pj_cli_telnet_cfg);
    pub fn pj_cli_telnet_create(cli: *mut pj_cli_t, param: *mut pj_cli_telnet_cfg, p_fe: *mut *mut pj_cli_front_end) -> pj_status_t;
    pub fn pj_cli_telnet_get_info(fe: *mut pj_cli_front_end, info: *mut pj_cli_telnet_info) -> pj_status_t;
}
